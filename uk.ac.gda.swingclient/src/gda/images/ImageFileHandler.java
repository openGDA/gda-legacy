/*-
 * Copyright Â© 2009 Diamond Light Source Ltd.
 *
 * This file is part of GDA.
 *
 * GDA is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 as published by the Free
 * Software Foundation.
 *
 * GDA is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along
 * with GDA. If not, see <http://www.gnu.org/licenses/>.
 */

package gda.images;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;

import javax.imageio.ImageIO;
import javax.swing.JComponent;
import javax.swing.JFileChooser;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * handle commands generated by FileMenu
 */
public class ImageFileHandler {
	private static final Logger logger = LoggerFactory.getLogger(ImageFileHandler.class);

	protected static JFileChooser openChooser = new JFileChooser();

	protected static JFileChooser saveChooser = new JFileChooser();

	private static String readFormats[] = ImageIO.getReaderFormatNames();

	private static String writeFormats[] = ImageIO.getReaderFormatNames();

	// private static JPanel saveChooserPanel;

	// private static ImageFileHandler fileHandler = new ImageFileHandler();

	private ImageFileHandler() {
		ImageFileFilter readFilter = new ImageFileFilter();
		ImageFileFilter writeFilter = new ImageFileFilter();

		// FIXME separate loops required for read and write
		for (int i = 0; i < readFormats.length; i++) {
			readFilter.addExtension(readFormats[i]);
			writeFilter.addExtension(writeFormats[i]);
		}
		readFilter.setDescription("All image files ");
		writeFilter.setDescription("All image files ");

		openChooser.setFileFilter(readFilter);
		saveChooser.setFileFilter(writeFilter);
	}

	/**
	 * @param in
	 * @param out
	 * @throws Exception
	 */
	public static void copyFile(File in, File out) throws Exception {
		FileInputStream fis = new FileInputStream(in);
		FileOutputStream fos = new FileOutputStream(out);
		byte[] buf = new byte[1024];
		int i = 0;
		while ((i = fis.read(buf)) != -1) {
			fos.write(buf, 0, i);
		}
		fis.close();
		fos.close();
	}

	/**
	 */
	public static void exit() {
		System.exit(0);
	}

	/**
	 * @param c
	 * @param saveFile
	 * @return String
	 */
	public static String getSaveFileSelection(JComponent c, String saveFile) {
		saveChooser.setSelectedFile(new File(saveFile));
		if (saveChooser.showSaveDialog(c) == JFileChooser.APPROVE_OPTION) {
			return saveChooser.getSelectedFile().getPath();
		}
		return null;
	}

	/**
	 * @param c
	 * @param openFile
	 * @return url
	 */
	public static String getOpenFileSelection(JComponent c, String openFile) {
		File file;
		if (openFile != null)
			file = new File(openFile);
		else
			file = null;
		openChooser.setSelectedFile(file);
		String url;
		if (openChooser.showOpenDialog(c) == JFileChooser.APPROVE_OPTION) {
			url = openChooser.getSelectedFile().getPath();
		} else {
			url = null;
		}
		return url;
	}

	/**
	 * read an image from the file specified in parameter userFile
	 * 
	 * @param imageFile
	 *            name
	 * @return BufferedImage
	 * @throws IOException
	 * @throws FileNotFoundException
	 */
	public static BufferedImage read(String imageFile) throws IOException, FileNotFoundException {
		// don't want a user message every time the display is updated so DON'T
		// use message output in this method

		BufferedImage image = null;
		if (validFormat(imageFile) && new File(imageFile).exists()) {
			try {
				if ((image = ImageIO.read(new File(imageFile))) == null) {
					throw new NullPointerException(" null image read from " + imageFile);
				}
				// MessageOutput.appendTextLater(" successfully read image from
				// file"
				// + imageFile);
			} catch (IOException e) {
				throw new IOException(" error reading file in ImageIO.read(" + imageFile + ")");
			}
		} else {
			logger.debug("ImageFileHandler.read: invalid file " + imageFile);
		}
		return image;
	}

	/**
	 * save image to file note that frame must implement ExitObserver
	 * 
	 * @param image
	 * @param fileName
	 */
	public static void save(BufferedImage image, String fileName) {
		String writeFormats[] = ImageIO.getWriterFormatNames();
		String fileType = fileName.substring(fileName.lastIndexOf(".") + 1);
		int i = 0;
		boolean validFormat = false;
		while (i < writeFormats.length) {
			if (writeFormats[i++].equals(fileType)) {
				validFormat = true;
				break;
			}
		}
		if (validFormat) {
			boolean found = false;
			try {
				found = ImageIO.write(image, fileType, new File(fileName));
			} catch (IOException e) {
				logger.error("caught IOException in ImageIO.write for file " + fileName);
			}
			if (found) {
				logger.warn("ImageDisplayPanel successfully saved " + fileName);
				// MessageOutput.appendTextLater(" successfully saved image to
				// file
				// "
				// + fileName);
			} else {
				logger.error("ImageDisplayPanel failed to save " + fileName);
			}
		} else {
			logger.error("ImageDisplayPanel.save: invalid file format," + fileType);
			logger.error(" supported formats are : " + Arrays.asList(writeFormats));
		}
	}

	/**
	 * @param file
	 * @return true if a valid format
	 */
	public static boolean validFormat(String file) {
		boolean validFormat = false;
		String readFormats[] = ImageIO.getReaderFormatNames();
		if (file != null) {
			String fileType = file.substring(file.lastIndexOf(".") + 1);
			int i = 0;
			while (i < readFormats.length) {
				if (readFormats[i++].equalsIgnoreCase(fileType)) {
					validFormat = true;
					break;
				}
			}
			if (!validFormat)
				logger.debug(" supported file formats are : " + Arrays.asList(readFormats));
		}
		return validFormat;
	}
}
